@pandas_udf(DoubleType())
def interpolar_2d(
    deltas: pd.Series, vencimentos: pd.Series, vols: pd.Series, 
    delta_interp: pd.Series, t_interp: pd.Series
) -> pd.Series:
    """
    Implementação manual da interpolação cúbica bidimensional (Delta x Tempo).
    Utiliza as equações (14) a (20) diretamente no código.
    """

    # Ordenação dos dados para garantir interpolação correta
    sorted_indices = np.lexsort((vencimentos.values, deltas.values))
    x = deltas.iloc[sorted_indices].values  # Deltas ordenados
    y = vencimentos.iloc[sorted_indices].values  # Vencimentos ordenados
    z = vols.iloc[sorted_indices].values  # Volatilidades ordenadas

    # Garantir que os valores de interpolação estão dentro da grade
    delta_interp_value = np.clip(delta_interp.iloc[0], x.min(), x.max())
    t_interp_value = np.clip(t_interp.iloc[0], y.min(), y.max())

    # Evitar erro de StopIteration garantindo que os índices existam
    i = next((i for i in range(1, len(x)) if x[i-1] <= delta_interp_value < x[i]), len(x) - 1)
    j = next((j for j in range(1, len(y)) if y[j-1] <= t_interp_value < y[j]), len(y) - 1)

    # Cálculo das segundas derivadas (Equações 14 e 15)
    f2_x_i_1 = (2 * (z[i] - z[i-1]) / (x[i] - x[i-1])**2)
    f2_x_i = (2 * (z[i] - z[i-1]) / (x[i] - x[i-1])**2)

    f2_y_j_1 = (2 * (z[j] - z[j-1]) / (y[j] - y[j-1])**2)
    f2_y_j = (2 * (z[j] - z[j-1]) / (y[j] - y[j-1])**2)

    # Coeficientes cúbicos para Delta (Equações 16 a 19)
    d_i = (f2_x_i - f2_x_i_1) / (6 * (x[i] - x[i-1]))
    c_i = (x[i] * f2_x_i_1 - x[i-1] * f2_x_i) / (2 * (x[i] - x[i-1]))
    b_i = ((z[i] - z[i-1]) - c_i * (x[i]**2 - x[i-1]**2) - d_i * (x[i]**3 - x[i-1]**3)) / (x[i] - x[i-1])
    a_i = z[i-1] - b_i * x[i-1] - c_i * x[i-1]**2 - d_i * x[i-1]**3

    # Coeficientes cúbicos para Tempo (Equações 16 a 19)
    d_j = (f2_y_j - f2_y_j_1) / (6 * (y[j] - y[j-1]))
    c_j = (y[j] * f2_y_j_1 - y[j-1] * f2_y_j) / (2 * (y[j] - y[j-1]))
    b_j = ((z[j] - z[j-1]) - c_j * (y[j]**2 - y[j-1]**2) - d_j * (y[j]**3 - y[j-1]**3)) / (y[j] - y[j-1])
    a_j = z[j-1] - b_j * y[j-1] - c_j * y[j-1]**2 - d_j * y[j-1]**3

    # Aplicação da interpolação cúbica bidimensional (Equação 20)
    vol_interpolado = (
        a_i + b_i * delta_interp_value + c_i * delta_interp_value**2 + d_i * delta_interp_value**3 +
        a_j + b_j * t_interp_value + c_j * t_interp_value**2 + d_j * t_interp_value**3
    )

    return pd.Series([vol_interpolado])  # Retorna uma Series conforme esperado pelo PySpark
