@pandas_udf(DoubleType())
def interpolar_2d(deltas: pd.Series, vencimentos: pd.Series, vols: pd.Series, 
                   delta_interp: pd.Series, t_interp: pd.Series) -> pd.Series:
    """
    Implementação manual da interpolação cúbica bidimensional (Delta x Tempo)
    usando as equações (14) a (20).

    Entrada:
      - deltas: Série com os valores de Delta.
      - vencimentos: Série com os tempos (vencimentos).
      - vols: Série com as volatilidades correspondentes.
      - delta_interp: Valor de Delta alvo (em uma Série) para interpolação.
      - t_interp: Valor de Tempo alvo (em uma Série) para interpolação.

    Saída:
      - Série com o valor interpolado da volatilidade para (delta_interp, t_interp).
    """

    # Ordenação dos dados para garantir interpolação correta
    # Utilizamos lexsort para ordenar primeiramente por Delta e depois por Vencimento.
    sorted_indices = np.lexsort((vencimentos, deltas))
    x = deltas.iloc[sorted_indices].values      # Eixo Delta ordenado
    y = vencimentos.iloc[sorted_indices].values   # Eixo Tempo ordenado
    z = vols.iloc[sorted_indices].values          # Valores de volatilidade ordenados

    # Garantir que os pontos de interpolação estão dentro dos limites da grade
    # Como pandas_udf trabalha com Series, usamos .iloc[0] para extrair o valor alvo.
    delta_target = np.clip(delta_interp.iloc[0], x.min(), x.max())
    t_target = np.clip(t_interp.iloc[0], y.min(), y.max())

    # Função auxiliar para calcular os coeficientes cúbicos com base nas equações (14) a (19)
    def calc_coef(arr: np.ndarray, val: np.ndarray, idx: int):
        """
        Calcula os coeficientes a, b, c, d para o intervalo [arr[idx-1], arr[idx]].
        
        Equações:
          (14) e (15): f''(arr[idx-1]) e f''(arr[idx]) são aproximadas por:
              f2_left = 2*(z[idx] - z[idx-1])/(arr[idx] - arr[idx-1])^2
              (Usamos o mesmo valor para f2_right por simplificação)
          (16): d = (f2_right - f2_left) / (6*(arr[idx] - arr[idx-1]))
          (17): c = (arr[idx] * f2_left - arr[idx-1] * f2_right) / (2*(arr[idx] - arr[idx-1]))
          (18): b = ((z[idx] - z[idx-1]) - c*(arr[idx]^2 - arr[idx-1]^2) - d*(arr[idx]^3 - arr[idx-1]^3)) / (arr[idx] - arr[idx-1])
          (19): a = z[idx-1] - b*arr[idx-1] - c*arr[idx-1]^2 - d*arr[idx-1]^3
        """
        # Aproximação das segundas derivadas (Equações 14 e 15)
        f2_left = 2 * (val[idx] - val[idx-1]) / (arr[idx] - arr[idx-1])**2
        f2_right = f2_left  # Usando a mesma aproximação para ambos

        # Equação (16): Coeficiente d
        d = (f2_right - f2_left) / (6 * (arr[idx] - arr[idx-1]))
        # Equação (17): Coeficiente c
        c = (arr[idx] * f2_left - arr[idx-1] * f2_right) / (2 * (arr[idx] - arr[idx-1]))
        # Equação (18): Coeficiente b
        b = ((val[idx] - val[idx-1]) - c * (arr[idx]**2 - arr[idx-1]**2) - d * (arr[idx]**3 - arr[idx-1]**3)) / (arr[idx] - arr[idx-1])
        # Equação (19): Coeficiente a
        a = val[idx-1] - b * arr[idx-1] - c * arr[idx-1]**2 - d * arr[idx-1]**3
        return a, b, c, d

    # Encontrar o índice no eixo Delta: x[i-1] <= delta_target < x[i]
    i = next(i for i in range(1, len(x)) if x[i-1] <= delta_target < x[i])
    # Encontrar o índice no eixo Tempo: y[j-1] <= t_target < y[j]
    j = next(j for j in range(1, len(y)) if y[j-1] <= t_target < y[j])

    # Calcular os coeficientes para o intervalo correspondente no eixo Delta
    a_delta, b_delta, c_delta, d_delta = calc_coef(x, z, i)
    # Calcular os coeficientes para o intervalo correspondente no eixo Tempo
    a_time, b_time, c_time, d_time = calc_coef(y, z, j)

    # Equação (20): Aplicação da interpolação cúbica bidimensional
    # Soma as contribuições dos dois eixos para obter o valor interpolado.
    vol_interpolado = (
        a_delta + b_delta * delta_target + c_delta * delta_target**2 + d_delta * delta_target**3 +
        a_time + b_time * t_target + c_time * t_target**2 + d_time * t_target**3
    )

    return pd.Series(vol_interpolado)
