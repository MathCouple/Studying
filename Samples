from pyspark.sql import SparkSession
from pyspark.sql.functions import pandas_udf, col
from pyspark.sql.types import DoubleType
import pandas as pd
import numpy as np

# Criando a Spark Session
spark = SparkSession.builder.appName("InterpolacaoManual2D").getOrCreate()

# Exemplo de Dados: Delta, Tempo (Dias) e Volatilidade Implícita
data = [
    (0.05, 1, 0.25), (0.05, 7, 0.28), (0.05, 14, 0.30),
    (0.05, 30, 0.32), (0.05, 60, 0.35), (0.10, 1, 0.20),
    (0.10, 7, 0.22), (0.10, 14, 0.24), (0.10, 30, 0.26),
    (0.10, 60, 0.29)
]
df = spark.createDataFrame(data, ["Delta", "Vencimento", "Vol"])

# UDF para interpolação cúbica bidimensional (Delta x Tempo)
@pandas_udf(DoubleType())
def interpolar_2d(deltas: pd.Series, vencimentos: pd.Series, vols: pd.Series, delta_interp: float, t_interp: float) -> pd.Series:
    """
    Implementação manual da interpolação cúbica bidimensional.
    Utiliza as equações (14) a (20) diretamente no código.
    """

    # Ordenação dos dados para garantir interpolação correta
    sorted_indices = np.lexsort((vencimentos, deltas))
    x = deltas.iloc[sorted_indices].values  # Deltas ordenados
    y = vencimentos.iloc[sorted_indices].values  # Vencimentos ordenados
    z = vols.iloc[sorted_indices].values  # Volatilidades ordenadas

    # Verificação de extrapolação (mantemos os valores mínimos e máximos)
    delta_interp = np.clip(delta_interp, x.min(), x.max())
    t_interp = np.clip(t_interp, y.min(), y.max())

    # Encontrar os índices mais próximos nos eixos Delta e Tempo
    i = next(i for i in range(1, len(x)) if x[i-1] <= delta_interp < x[i])
    j = next(j for j in range(1, len(y)) if y[j-1] <= t_interp < y[j])

    # Cálculo das segundas derivadas (Equações 14 e 15)
    f2_x_i_1 = (2 * (z[i] - z[i-1]) / (x[i] - x[i-1])**2)
    f2_x_i = (2 * (z[i] - z[i-1]) / (x[i] - x[i-1])**2)

    f2_y_j_1 = (2 * (z[j] - z[j-1]) / (y[j] - y[j-1])**2)
    f2_y_j = (2 * (z[j] - z[j-1]) / (y[j] - y[j-1])**2)

    # Coeficientes cúbicos (Equações 16 a 19)
    d_i = (f2_x_i - f2_x_i_1) / (6 * (x[i] - x[i-1]))
    c_i = (x[i] * f2_x_i_1 - x[i-1] * f2_x_i) / (2 * (x[i] - x[i-1]))
    b_i = ((z[i] - z[i-1]) - c_i * (x[i]**2 - x[i-1]**2) - d_i * (x[i]**3 - x[i-1]**3)) / (x[i] - x[i-1])
    a_i = z[i-1] - b_i * x[i-1] - c_i * x[i-1]**2 - d_i * x[i-1]**3

    d_j = (f2_y_j - f2_y_j_1) / (6 * (y[j] - y[j-1]))
    c_j = (y[j] * f2_y_j_1 - y[j-1] * f2_y_j) / (2 * (y[j] - y[j-1]))
    b_j = ((z[j] - z[j-1]) - c_j * (y[j]**2 - y[j-1]**2) - d_j * (y[j]**3 - y[j-1]**3)) / (y[j] - y[j-1])
    a_j = z[j-1] - b_j * y[j-1] - c_j * y[j-1]**2 - d_j * y[j-1]**3

    # Aplicação da interpolação cúbica bidimensional (Equação 20)
    vol_interpolado = (
        a_i + b_i * delta_interp + c_i * delta_interp**2 + d_i * delta_interp**3 +
        a_j + b_j * t_interp + c_j * t_interp**2 + d_j * t_interp**3
    )

    return pd.Series(vol_interpolado)

# Aplicando a interpolação diretamente para um ponto específico (Delta = 5%, Tempo = 1 dia)
delta_target = 0.05  # 5% de delta
t_target = 1  # 1 dia

df_resultado = df.agg(interpolar_2d(col("Delta"), col("Vencimento"), col("Vol"), delta_target, t_target).alias("Vol_Final"))

# Exibir o resultado final
df_resultado.show()
