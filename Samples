from pyspark.sql.functions import udf
from pyspark.sql.types import DoubleType

# ====================================================================
# Função: calc_derivative
# ====================================================================
def calc_derivative(x, y, idx, side):
    """
    Calcula a primeira derivada f'(x) em um ponto usando regras de 
    diferenças finitas “constrained”, diferenciando o tratamento para 
    o primeiro (side = 'left'), o último (side = 'right') e pontos internos.
    
    Regras:
      - Para o primeiro ponto: se houver pelo menos 3 pontos, calcula a
        condição cond = ((x[2]-x[1])/(y[2]-y[1])) - ((x[1]-x[0])/(y[1]-y[0])).  
        Se cond < 0, utiliza a diferença simples; caso contrário, utiliza uma
        fórmula suavizada: f'(x₀) = [3(y₁-y₀)]/[2(x₁-x₀)] – f'(x₂)/2.
      - Para o último ponto: aplica a mesma lógica com os últimos 3 pontos.
      - Para pontos internos: se há um ponto à frente, calcula cond e usa
        a diferença centrada ou a fórmula suavizada, conforme cond.
    """
    n = len(x)
    if side == 'left':  # Primeiro ponto (x₀)
        if n > 2:
            cond = ((x[2] - x[1]) / (y[2] - y[1])) - ((x[1] - x[0]) / (y[1] - y[0]))
            if cond < 0:
                return (y[1] - y[0]) / (x[1] - x[0])
            else:
                fprime_next = (y[2] - y[1]) / (x[2] - x[1])
                return (3 * (y[1] - y[0]) / (2 * (x[1] - x[0]))) - (fprime_next / 2)
        else:
            return (y[1] - y[0]) / (x[1] - x[0])
    elif side == 'right':  # Último ponto
        if n > 2:
            cond = ((x[n-1] - x[n-2]) / (y[n-1] - y[n-2])) - ((x[n-2] - x[n-3]) / (y[n-2] - y[n-3]))
            if cond < 0:
                return (y[n-1] - y[n-2]) / (x[n-1] - x[n-2])
            else:
                fprime_temp = (y[n-1] - y[n-2]) / (x[n-1] - x[n-2])
                return (3 * (y[n-1] - y[n-2]) / (2 * (x[n-1] - x[n-2]))) - (fprime_temp / 2)
        else:
            return (y[n-1] - y[n-2]) / (x[n-1] - x[n-2])
    else:  # Ponto interior
        if idx + 1 < n - 1:
            cond = ((x[idx+2] - x[idx+1]) / (y[idx+2] - y[idx+1])) - ((x[idx+1] - x[idx]) / (y[idx+1] - y[idx]))
            if cond < 0:
                return (y[idx+1] - y[idx-1]) / (x[idx+1] - x[idx-1])
            else:
                fprime_next = (y[idx+2] - y[idx+1]) / (x[idx+2] - x[idx+1])
                return (3 * (y[idx+1] - y[idx]) / (2 * (x[idx+1] - x[idx]))) - (fprime_next / 2)
        else:
            return (y[idx] - y[idx-1]) / (x[idx] - x[idx-1])

# ====================================================================
# Função: cubic_spline_interp
# ====================================================================
def cubic_spline_interp(x, y, x_interp):
    """
    Realiza a interpolação cúbica “constrained” unidimensional usando as 
    Equações (14) a (20).
    
    Passos:
      1. Verifica se x_interp está fora dos limites; se sim, retorna a extremidade.
      2. Localiza o intervalo [x[i-1], x[i]] que contém x_interp.
      3. Calcula as derivadas nos extremos usando calc_derivative.
      4. Calcula as segundas derivadas:
           f″(x[i-1]) = [2(m₁ - m₀)]/(x[i]-x[i-1]) + [6(y[i]-y[i-1])]/(x[i]-x[i-1])²
           f″(x[i])   = [2(m₁ + m₀)]/(x[i]-x[i-1]) + [6(y[i]-y[i-1])]/(x[i]-x[i-1])²
      5. Calcula os coeficientes (Equações 16 a 19).
      6. Retorna y(x_interp) = a + b*x_interp + c*x_interp² + d*x_interp³.
    """
    n = len(x)
    if x_interp <= x[0]:
        return y[0]
    if x_interp >= x[-1]:
        return y[-1]
    i = 1
    while i < n and x_interp > x[i]:
        i += 1
    x0, x1 = x[i-1], x[i]
    y0, y1 = y[i-1], y[i]
    m0 = calc_derivative(x, y, 0 if i-1 == 0 else i-1, 'left' if i-1 == 0 else 'interior')
    m1 = calc_derivative(x, y, n-1 if i == n-1 else i, 'right' if i == n-1 else 'interior')
    f2_x0 = (2 * (m1 - m0)) / (x1 - x0) + (6 * (y1 - y0)) / ((x1 - x0)**2)
    f2_x1 = (2 * (m1 + m0)) / (x1 - x0) + (6 * (y1 - y0)) / ((x1 - x0)**2)
    d = (f2_x1 - f2_x0) / (6 * (x1 - x0))
    c = (x1 * f2_x0 - x0 * f2_x1) / (2 * (x1 - x0))
    b = ((y1 - y0) - c * (x1**2 - x0**2) - d * (x1**3 - x0**3)) / (x1 - x0)
    a = y0 - b * x0 - c * (x0**2) - d * (x0**3)
    return a + b * x_interp + c * (x_interp**2) + d * (x_interp**3)

# ====================================================================
# Função: bidimensional_interp
# ====================================================================
def bidimensional_interp(deltas, tempos, vol_matrix, delta_interp, tempo_interp):
    """
    Realiza a interpolação bidimensional em dois eixos (delta e tempo).
    
    Passos:
      1. Para cada linha da matriz (cada tempo), interpola no eixo delta usando
         cubic_spline_interp com x = deltas, y = linha de volatilidades e x_interp = delta_interp.
      2. Com o vetor resultante (um valor por tempo), interpola no eixo tempo com
         x = tempos, y = vetor interpolado e x_interp = tempo_interp.
      3. Retorna o valor final interpolado.
    """
    interp_por_tempo = [cubic_spline_interp(deltas, row, delta_interp) for row in vol_matrix]
    return cubic_spline_interp(tempos, interp_por_tempo, tempo_interp)

# ====================================================================
# UDF: interp_vol_udf
# ====================================================================
@udf(DoubleType())
def interp_vol_udf(volatilidades, tempos, deltas, delta_interp, tempo_interp):
    """
    UDF para Spark que realiza a interpolação bidimensional da superfície de volatilidade.
    
    Parâmetros de entrada:
      - volatilidades: array linear de floats (tamanho N), onde cada posição corresponde a um
        ponto (tempo, delta) e podem existir duplicatas.
      - tempos: array de floats representando os tempos (com possíveis repetições).
      - deltas: array de floats representando os deltas (com possíveis repetições).
      - delta_interp: float com o valor de consulta para o eixo delta.
      - tempo_interp: float com o valor de consulta para o eixo tempo.
      
    Adaptação para dados repetidos:
      - Monta um dicionário que mapeia (tempo, delta) → volatilidade, somando os valores
        quando houver duplicatas.
      - Deduplica e ordena os eixos a partir dos dados.
      - Reconstrói a matriz 2D de volatilidades (grid) a partir dos eixos únicos.
      - Chama bidimensional_interp para retornar a volatilidade interpolada.
    """
    # Dictionary comprehension para agrupar e somar os valores para cada (tempo, delta)
    data_dict = {
        key: sum(v for (t, d), v in zip(zip(tempos, deltas), volatilidades) if (t, d) == key)
        for key in set(zip(tempos, deltas))
    }
    unique_tempos = sorted(set(tempos))
    unique_deltas = sorted(set(deltas))
    vol_matrix = [[data_dict[(t, d)] for d in unique_deltas] for t in unique_tempos]
    return float(bidimensional_interp(unique_deltas, unique_tempos, vol_matrix, delta_interp, tempo_interp))
