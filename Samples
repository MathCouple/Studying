@pandas_udf(DoubleType())
def interpolar_2d(deltas: pd.Series, vencimentos: pd.Series, vols: pd.Series, 
                   delta_interp: pd.Series, t_interp: pd.Series) -> pd.Series:
    """
    Implementação manual da interpolação cúbica bidimensional (Delta x Tempo).
    Corrigido para evitar StopIteration quando o valor de interpolação está fora dos limites.
    """

    # Ordenação dos dados para garantir interpolação correta
    sorted_indices = np.lexsort((vencimentos, deltas))
    x = deltas.iloc[sorted_indices].values      # Eixo Delta ordenado
    y = vencimentos.iloc[sorted_indices].values   # Eixo Tempo ordenado
    z = vols.iloc[sorted_indices].values          # Valores de volatilidade ordenados

    # Garantir que os pontos de interpolação estão dentro dos limites da grade
    delta_target = np.clip(delta_interp.iloc[0], x.min(), x.max())
    t_target = np.clip(t_interp.iloc[0], y.min(), y.max())

    # Função auxiliar para encontrar o índice correto no intervalo
    def encontrar_indice(arr, target):
        """
        Retorna o índice do intervalo correto para interpolação.
        Se o valor for menor que o mínimo, retorna 1.
        Se o valor for maior que o máximo, retorna len(arr)-1.
        """
        for idx in range(1, len(arr)):
            if arr[idx-1] <= target < arr[idx]:
                return idx
        return len(arr) - 1  # Retorna o último intervalo válido

    # Encontrar o índice no eixo Delta e no eixo Tempo
    i = encontrar_indice(x, delta_target)
    j = encontrar_indice(y, t_target)

    # Função auxiliar para calcular os coeficientes cúbicos
    def calc_coef(arr: np.ndarray, val: np.ndarray, idx: int):
        """
        Calcula os coeficientes a, b, c, d para o intervalo [arr[idx-1], arr[idx]].
        """

        # Aproximação das segundas derivadas (Equações 14 e 15)
        f2_left = 2 * (val[idx] - val[idx-1]) / (arr[idx] - arr[idx-1])**2
        f2_right = f2_left  # Usando a mesma aproximação para ambos

        # Equação (16): Coeficiente d
        d = (f2_right - f2_left) / (6 * (arr[idx] - arr[idx-1]))
        # Equação (17): Coeficiente c
        c = (arr[idx] * f2_left - arr[idx-1] * f2_right) / (2 * (arr[idx] - arr[idx-1]))
        # Equação (18): Coeficiente b
        b = ((val[idx] - val[idx-1]) - c * (arr[idx]**2 - arr[idx-1]**2) - d * (arr[idx]**3 - arr[idx-1]**3)) / (arr[idx] - arr[idx-1])
        # Equação (19): Coeficiente a
        a = val[idx-1] - b * arr[idx-1] - c * arr[idx-1]**2 - d * arr[idx-1]**3
        return a, b, c, d

    # Calcular coeficientes para os eixos Delta e Tempo
    a_delta, b_delta, c_delta, d_delta = calc_coef(x, z, i)
    a_time, b_time, c_time, d_time = calc_coef(y, z, j)

    # Equação (20): Aplicação da interpolação cúbica bidimensional
    vol_interpolado = (
        a_delta + b_delta * delta_target + c_delta * delta_target**2 + d_delta * delta_target**3 +
        a_time + b_time * t_target + c_time * t_target**2 + d_time * t_target**3
    )

    return pd.Series(vol_interpolado)
