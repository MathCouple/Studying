from pyspark.sql import SparkSession
from pyspark.sql.functions import pandas_udf, col
from pyspark.sql.types import DoubleType
import pandas as pd
import numpy as np
from scipy.interpolate import CubicSpline

# Criando a Spark Session
spark = SparkSession.builder.appName("InterpolacaoCubicaRestrita").getOrCreate()

# Exemplo de Dados: Delta, Tempo (Dias) e Volatilidade Implícita
data = [
    (0.1, 30, 0.25), (0.1, 60, 0.28), (0.1, 90, 0.30),
    (0.1, 120, 0.32), (0.1, 150, 0.35), (0.2, 30, 0.20),
    (0.2, 60, 0.22), (0.2, 90, 0.24), (0.2, 120, 0.26),
    (0.2, 150, 0.29)
]
df = spark.createDataFrame(data, ["Delta", "Vencimento", "Vol"])

# Definição da UDF para interpolação cúbica restrita no tempo
@pandas_udf(DoubleType())
def interpolar_vol(vencimentos: pd.Series, vols: pd.Series, x_interp: float) -> pd.Series:
    """
    Aplica a interpolação cúbica restrita nos pontos (Vencimento, Volatilidade Implícita)
    para estimar a volatilidade no ponto x_interp.
    """

    # Equação (14) e (15): Cálculo da segunda derivada da spline cúbica restrita
    sorted_indices = np.argsort(vencimentos)
    x = vencimentos.iloc[sorted_indices].values  # Ordenamos os vencimentos
    y = vols.iloc[sorted_indices].values  # Correspondentes valores de volatilidade

    # Verificação de extrapolação: Se x_interp estiver fora dos limites conhecidos
    if x_interp < x[0] or x_interp > x[-1]:
        return pd.Series(y[0] if x_interp < x[0] else y[-1])

    # Criando a spline cúbica restrita (monotônica), garantindo suavidade
    spline = CubicSpline(x, y, bc_type="natural", extrapolate=False)

    # Equação (20): Aplicação da interpolação cúbica
    return pd.Series(spline(x_interp))

# Interpolação no eixo do tempo para cada Delta fixo
x_interp = 75  # Exemplo: Queremos volatilidade para 75 dias
df_temporal = df.groupBy("Delta").agg(interpolar_vol(col("Vencimento"), col("Vol"), x_interp).alias("Vol_Interpolado"))

# Agora interpolamos no eixo do Delta para obter um valor contínuo

@pandas_udf(DoubleType())
def interpolar_delta(deltas: pd.Series, vols: pd.Series, delta_interp: float) -> pd.Series:
    """
    Aplica a interpolação cúbica restrita nos pontos (Delta, Volatilidade Interpolada)
    para estimar a volatilidade no ponto delta_interp.
    """

    # Equação (14) e (15): Cálculo da segunda derivada para Delta
    sorted_indices = np.argsort(deltas)
    x = deltas.iloc[sorted_indices].values  # Ordenamos os deltas
    y = vols.iloc[sorted_indices].values  # Correspondentes volatilidades interpoladas no tempo

    # Verificação de extrapolação
    if delta_interp < x[0] or delta_interp > x[-1]:
        return pd.Series(y[0] if delta_interp < x[0] else y[-1])

    # Criando a spline cúbica restrita para Delta
    spline = CubicSpline(x, y, bc_type="natural", extrapolate=False)

    # Equação (20): Aplicação da interpolação cúbica
    return pd.Series(spline(delta_interp))

# Supondo que queremos interpolar também no eixo Delta
delta_interp = 0.15
df_final = df_temporal.agg(interpolar_delta(col("Delta"), col("Vol_Interpolado"), delta_interp).alias("Vol_Final"))

# Exibir o resultado final
df_final.show()
