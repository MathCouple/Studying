from pyspark.sql.functions import udf
from pyspark.sql.types import DoubleType

# ====================================================================
# Função: calc_derivative
# ====================================================================
def calc_derivative(x, y, idx, side):
    """
    Calcula a primeira derivada f'(x) em um ponto usando regras de 
    diferenças finitas “constrained” segundo o lado do ponto (início, 
    interior ou final).

    Parâmetros:
      - x: lista dos pontos do eixo independente.
      - y: lista dos pontos do eixo dependente.
      - idx: índice do ponto onde a derivada será calculada.
      - side: string que indica se é o primeiro ('left'), último ('right')
              ou um ponto intermediário ('interior').

    Regras aplicadas:
      1. Para o primeiro ponto (side == 'left'):
         - Se houver pelo menos 3 pontos, calcula:
           cond = ((x[2]-x[1])/(y[2]-y[1])) - ((x[1]-x[0])/(y[1]-y[0])).
         - Se cond < 0, utiliza a diferença simples:
           f'(x₀) = (y₁ - y₀)/(x₁ - x₀).
         - Caso contrário, utiliza a fórmula:
           f'(x₀) = [3(y₁ - y₀)]⁄[2(x₁ - x₀)] – f'(x₂)/2,
           onde f'(x₂) é a derivada simples entre o segundo e terceiro pontos.
      
      2. Para o último ponto (side == 'right'):
         - De forma análoga, se houver pelo menos 3 pontos, calcula:
           cond = ((xₙ - xₙ₋₁)/(yₙ - yₙ₋₁)) - ((xₙ₋₁ - xₙ₋₂)/(yₙ₋₁ - yₙ₋₂)).
         - Se cond < 0, usa a diferença simples:
           f'(xₙ) = (yₙ - yₙ₋₁)/(xₙ - xₙ₋₁).
         - Caso contrário, aplica a fórmula análoga ao caso inicial.
      
      3. Para pontos internos (side == 'interior'):
         - Se existir um ponto “à frente” (ou seja, se idx+2 < len(x)):
           - Calcula:
             cond = ((x[idx+2]-x[idx+1])/(y[idx+2]-y[idx+1])) - ((x[idx+1]-x[idx])/(y[idx+1]-y[idx])).
           - Se cond < 0, utiliza a diferença centrada:
             f'(xᵢ) = (y[i+1] - y[i-1])/(x[i+1] - x[i-1]).
           - Caso contrário, utiliza:
             f'(xᵢ) = [3(y[i+1] - y[i])]/[2(x[i+1]-x[i])] – f'(x[i+2])/2.
         - Se não houver pontos suficientes à frente, recorre à diferença simples.
    """
    n = len(x)
    if side == 'left':  # Primeiro ponto (x₀)
        if n > 2:
            cond = ((x[2] - x[1]) / (y[2] - y[1])) - ((x[1] - x[0]) / (y[1] - y[0]))
            if cond < 0:
                return (y[1] - y[0]) / (x[1] - x[0])
            else:
                fprime_next = (y[2] - y[1]) / (x[2] - x[1])
                return (3 * (y[1] - y[0]) / (2 * (x[1] - x[0]))) - (fprime_next / 2)
        else:
            return (y[1] - y[0]) / (x[1] - x[0])
    elif side == 'right':  # Último ponto
        if n > 2:
            cond = ((x[n-1] - x[n-2]) / (y[n-1] - y[n-2])) - ((x[n-2] - x[n-3]) / (y[n-2] - y[n-3]))
            if cond < 0:
                return (y[n-1] - y[n-2]) / (x[n-1] - x[n-2])
            else:
                fprime_temp = (y[n-1] - y[n-2]) / (x[n-1] - x[n-2])
                return (3 * (y[n-1] - y[n-2]) / (2 * (x[n-1] - x[n-2]))) - (fprime_temp / 2)
        else:
            return (y[n-1] - y[n-2]) / (x[n-1] - x[n-2])
    else:  # Ponto interior
        if idx + 1 < n - 1:
            cond = ((x[idx+2] - x[idx+1]) / (y[idx+2] - y[idx+1])) - ((x[idx+1] - x[idx]) / (y[idx+1] - y[idx]))
            if cond < 0:
                return (y[idx+1] - y[idx-1]) / (x[idx+1] - x[idx-1])
            else:
                fprime_next = (y[idx+2] - y[idx+1]) / (x[idx+2] - x[idx+1])
                return (3 * (y[idx+1] - y[idx]) / (2 * (x[idx+1] - x[idx]))) - (fprime_next / 2)
        else:
            return (y[idx] - y[idx-1]) / (x[idx] - x[idx-1])

# ====================================================================
# Função: cubic_spline_interp
# ====================================================================
def cubic_spline_interp(x, y, x_interp):
    """
    Realiza a interpolação cúbica “constrained” unidimensional usando as 
    Equações (14) a (20).

    Passos:
      1. **Verificação de Fronteira:**  
         Se x_interp for menor ou igual ao primeiro ponto de x, retorna y[0].  
         Se x_interp for maior ou igual ao último ponto, retorna y[-1].

      2. **Localização do Intervalo:**  
         Encontra o índice i tal que x[i-1] ≤ x_interp ≤ x[i].

      3. **Cálculo das Derivadas (f'):**  
         Utiliza a função calc_derivative para obter:
         - m₀ = f'(x[i-1]) (usando a regra 'left' se for o primeiro ou 'interior').
         - m₁ = f'(x[i]) (usando a regra 'right' se for o último ou 'interior').

      4. **Cálculo das Segundas Derivadas (f″):**  
         Aplica as Equações:
           - f″(x[i-1]) = [2(m₁ - m₀)]⁄(x[i]-x[i-1]) + [6(y[i]-y[i-1])]/(x[i]-x[i-1])²  (Equação 14)
           - f″(x[i])   = [2(m₁ + m₀)]⁄(x[i]-x[i-1]) + [6(y[i]-y[i-1])]/(x[i]-x[i-1])²  (Equação 15)

      5. **Cálculo dos Coeficientes da Spline:**  
         Calcula os coeficientes da interpolação cúbica:
           - d = [f″(x[i]) - f″(x[i-1])]⁄[6(x[i]-x[i-1])]  (Equação 16)
           - c = [x[i]·f″(x[i-1]) - x[i-1]·f″(x[i])]⁄[2(x[i]-x[i-1])]  (Equação 17)
           - b = { (y[i]-y[i-1]) - c·(x[i]² - x[i-1]²) - d·(x[i]³ - x[i-1]³) }⁄(x[i]-x[i-1])  (Equação 18)
           - a = y[i-1] - b·x[i-1] - c·x[i-1]² - d·x[i-1]³  (Equação 19)

      6. **Avaliação da Spline:**  
         Calcula o valor interpolado:
           y(x_interp) = a + b·x_interp + c·x_interp² + d·x_interp³  (Equação 20)
    """
    n = len(x)
    if x_interp <= x[0]:
        return y[0]
    if x_interp >= x[-1]:
        return y[-1]
    # Localiza o intervalo [x[i-1], x[i]]
    i = 1
    while i < n and x_interp > x[i]:
        i += 1
    x0, x1 = x[i-1], x[i]
    y0, y1 = y[i-1], y[i]
    
    # Calcula as derivadas nos extremos do intervalo
    m0 = calc_derivative(x, y, 0 if i-1 == 0 else i-1, 'left' if i-1 == 0 else 'interior')
    m1 = calc_derivative(x, y, n-1 if i == n-1 else i, 'right' if i == n-1 else 'interior')
    
    # Cálculo das segundas derivadas segundo as Equações 14 e 15
    f2_x0 = (2 * (m1 - m0)) / (x1 - x0) + (6 * (y1 - y0)) / ((x1 - x0)**2)
    f2_x1 = (2 * (m1 + m0)) / (x1 - x0) + (6 * (y1 - y0)) / ((x1 - x0)**2)
    
    # Cálculo dos coeficientes (Equações 16 a 19)
    d = (f2_x1 - f2_x0) / (6 * (x1 - x0))
    c = (x1 * f2_x0 - x0 * f2_x1) / (2 * (x1 - x0))
    b = ((y1 - y0) - c * (x1**2 - x0**2) - d * (x1**3 - x0**3)) / (x1 - x0)
    a = y0 - b * x0 - c * (x0**2) - d * (x0**3)
    
    # Avalia a spline no ponto x_interp (Equação 20)
    return a + b * x_interp + c * (x_interp**2) + d * (x_interp**3)

# ====================================================================
# Função: bidimensional_interp
# ====================================================================
def bidimensional_interp(deltas, tempos, vol_matrix, delta_interp, tempo_interp):
    """
    Realiza a interpolação bidimensional em dois eixos (delta e tempo):

      1. **Interpola no Eixo Delta:**  
         Para cada linha da matriz de volatilidades (correspondente a um tempo),
         interpola-se no eixo delta usando a função cubic_spline_interp com:
           - x = deltas,
           - y = linha da matriz (valores de volatilidade para cada delta),
           - x_interp = delta_interp.
         O resultado é uma lista de valores interpolados, um para cada tempo.

      2. **Interpola no Eixo Tempo:**  
         Com o vetor de valores obtido no passo anterior (um para cada tempo),
         interpola-se no eixo tempo:
           - x = tempos,
           - y = vetor de valores interpolados (por tempo),
           - x_interp = tempo_interp.
         Retorna o valor final interpolado.
    """
    interp_por_tempo = []
    for row in vol_matrix:
        interp_por_tempo.append(cubic_spline_interp(deltas, row, delta_interp))
    return cubic_spline_interp(tempos, interp_por_tempo, tempo_interp)

# ====================================================================
# UDF: interp_vol_udf
# ====================================================================
@udf(DoubleType())
def interp_vol_udf(volatilidades, tempos, deltas, delta_interp, tempo_interp):
    """
    UDF para uso em Spark que realiza a interpolação bidimensional.

    Parâmetros de entrada:
      - volatilidades: array linear de floats com tamanho = len(tempos)*len(deltas).  
        Os valores devem estar ordenados de forma que os primeiros len(deltas)
        elementos correspondam ao primeiro tempo, os próximos len(deltas) ao segundo, etc.
      - tempos: array de floats (e.g., [t₁, t₂, ..., tₙ]), ordenado.
      - deltas: array de floats (e.g., [d₁, d₂, ..., dₘ]), ordenado.
      - delta_interp: valor float de consulta no eixo delta.
      - tempo_interp: valor float de consulta no eixo tempo.

    Processo:
      1. Reconstroi-se a "matriz" de volatilidades a partir do array linear, 
         particionando-o em n linhas, onde n = len(tempos) e cada linha tem m elementos (m = len(deltas)).
      2. Chama a função bidimensional_interp para obter o valor interpolado.
      3. Retorna o valor final.
    """
    n_d = len(deltas)
    n_t = len(tempos)
    vol_matrix = [volatilidades[i * n_d : (i + 1) * n_d] for i in range(n_t)]
    return float(bidimensional_interp(deltas, tempos, vol_matrix, delta_interp, tempo_interp))
